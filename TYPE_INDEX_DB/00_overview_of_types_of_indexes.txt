Обзор типов индексов Oracle, MySQL, PostgresQL, MS SQL.

1. B-TREE 

  Семейство B-TREE (би дерево) - это наиболее часто используемый тип индексов, 
    организованных как сбалансированное дерево, упорядоченных ключей. 
    Они поддерживаются практически всеми СУБД как реляционными, так 
    нереляционными, и практически для всех типов данных.
    
    Данный тип индекса оптимален для множества с хорошим распределением 
    значений и высокой мощностью(cardinality-количество уникальных значений)
    
    1) Red-black tree, RB tree (Красно-черное дерево)
    2) AA-дерево
    3) АВЛ-дерево
    4) Декартово дерево
    5) Splay-дерево (скошенное дерево)
    6) Scapegoat-дерево ('козел отпущения')
    
    
2. Пространственные индексы

В схеме работы пространственных запросов обычно выделяют две стадии или две ступени фильтрации. 
  СУБД, обладающие слабой пространственной поддержкой, отрабатывают только первую ступень (грубая фильтрация, MySQL). 
  Как правило, на этой стадии используется приближенное, аппроксимированное представление объектов. 
  Самый распространенный тип аппроксимации – минимальный ограничивающий прямоугольник (MBR – Minimum Bounding Rectangle).
  
Для пространственных типов данных существуют особые методы индексирования на основе 
  R-деревьев(R-Tree index) и 
  сеток(Grid-based Spatial index).
  
  Spatial grid

  2.1. Spatial grid(пространственная сетка) index – это древовидная структура, подобная B-дереву, 
     но используется для организации доступа к пространственным(Spatial) данным, то есть для индексации многомерной информации, 
     такой, например, как географические данные с двумерными координатами(широтой и долготой). 
     
     В этой структуре узлами дерева выступают ячейки пространства. 
     Например, для двухмерного пространства: сначала вся родительская площадь будет разбита на сетку строго 
     определенного разрешения, затем каждая ячейка сетки, в которой количество объектов превышает установленный 
     максимум объектов в ячейке, будет разбита на подсетку следующего уровня. 
     Этот процесс будет продолжаться до тех пор, пока не будет достигнут максимум вложенности (если установлен), 
     или пока все не будет разделено до ячеек, не превышающих максимум объектов. 
     
     В случае трехмерного или многомерного пространства это будут прямоугольные параллелепипеды (кубоиды) или параллелотопы.

  2.2. Quadtree (квадрадерево)

     Quadtree – это подвид Grid-based Spatial index, в котором в родительской ячейке всегда 4 потомка и разрешение сетки варьируется
     в зависимости от характера или сложности данных.
     
  2.3. R-Tree (Регионы дерево)

     R-Tree (Regions Tree) – это тоже древовидная структура данных подобная Spatial Grid, предложенная в 1984 году Антонином Гуттманом. 
     Эта структура данных тоже разбивает пространство на множество иерархически вложенных ячеек, но которые, в отличие от Spatial Grid, 
     не обязаны полностью покрывать родительскую ячейку и могут пересекаться.

     Для расщепления переполненных вершин могут применяться различные алгоритмы, что порождает деление R-деревьев на подтипы: 
       с квадратичной и линейной сложностью.
       
     Квадратичный подтип заключается в разбиении на два прямоугольника с минимальной площадью, покрывающие все объекты. 
     Линейный – в разбиении по максимальной удаленности. 
     
3. HASH

  Hash-индексы были предложены Артуром Фуллером, и предполагают хранение не самих значений, а их хэшей, 
    благодаря чему уменьшается размер(а, соответственно, и увеличивается скорость их обработки) 
    индексов из больших полей. 
    
    Таким образом, при запросах с использованием HASH-индексов, сравниваться будут не искомое со значения поля, 
    а хэш от искомого значения с хэшами полей. 
    
    Из-за нелинейнойсти хэш-функций данный индекс нельзя сортировать по значению, что приводит к невозможности 
    использования в сравнениях больше/меньше и «is null». 
    Кроме того, так как хэши не уникальны, то для совпадающих хэшей применяются методы разрешения коллизий.
    
4. Bitmap (Битовая карта)

  Bitmap index – метод битовых индексов заключается в создании отдельных битовых карт (последовательность 0 и 1) 
    для каждого возможного значения столбца, где каждому биту соответствует строка с индексируемым значением, 
    а его значение равное 1 означает, что запись, соответствующая позиции бита содержит индексируемое значение
    для данного столбца или свойства.
    
  Основное преимущество битовых индексов в том, что на больших множествах с низкой мощностью и 
    хорошей кластеризацией по их значениям индекс будет меньше чем B*-tree.

5. Reverse index (Обратный индекс)

   Reverse index – это тоже B-tree индекс но с реверсированным ключом, 
   используемый в основном для монотонно возрастающих значений(например, автоинкрементный идентификатор) 
   в OLTP системах с целью снятия конкуренции за последний листовой блок индекса, 
   т.к. благодаря переворачиванию значения две соседние записи индекса попадают в разные блоки индекса. 
   
   Он не может использоваться для диапазонного поиска.
   
   Как видите, значение в индексе изменяется намного больше, чем само значение в таблице, и поэтому 
   в структуре b-tree, они попадут в разные блоки. 
   
6. Inverted index (Перевернутый индекс)

   Инвертированный индекс – это полнотекстовый индекс, хранящий для каждого лексемы ключей отсортированный 
   список адресов записей таблицы, которые содержат данный ключ.

7. Partial index (Частичный индекс)

   Partial index — это индекс, построенный на части таблицы, удовлетворяющей определенному условию самого индекса. 
     Данный индекс создан для уменьшения размера индекса.
   

8. Function-based index (функциональный индекс)

  Самим же гибким типом индексов являются функциональные индексы, то есть индексы, 
    ключи которых хранят результат пользовательских функций. 
    
  Функциональные индексы часто строятся для полей, значения которых проходят 
    предварительную обработку перед сравнением в команде SQL. 
    
  Например, при сравнении строковых данных без учета регистра символов часто используется функция UPPER. 
  
  Создание функционального индекса с функцией UPPER улучшает эффективность таких сравнений.
  
--------------------------------------------------------------------------------------------------------------------  

Сводная таблица типов индексов
Картинка во вложении
