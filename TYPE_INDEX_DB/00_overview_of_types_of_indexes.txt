Обзор типов индексов Oracle, MySQL, PostgresQL, MS SQL.

1. B-TREE 

  Семейство B-TREE (би дерево) - это наиболее часто используемый тип индексов, 
    организованных как сбалансированное дерево, упорядоченных ключей. 
    Они поддерживаются практически всеми СУБД как реляционными, так 
    нереляционными, и практически для всех типов данных.
    
    Данный тип индекса оптимален для множества с хорошим распределением 
    значений и высокой мощностью(cardinality-количество уникальных значений)
    
    1) Red-black tree, RB tree (Красно-черное дерево)
        В этой структуре баланс достигается за счет поддержания раскраски вершин в два цвета 
        (красный и черный, как видно из названия :), подчиняющейся следующим правилам:
            1.1 Красная вершина не может быть сыном красной вершины
            1.2 Черная глубина любого листа одинакова (черной глубиной называют количество 
              черных вершин на пути из корня)
            1.3 Корень дерева черный
    
    2) AA-дерево
        Модификация красно-черного дерева, в которой накладывается дополнительное ограничение: 
          красная вершина может быть только правым сыном. 
          Если красно-черное дерово изоморфно 2-3-4 дереву, то AA-дерево изоморфно 2-3 дереву.
          Из-за дополнительного ограничения операции реализуются проще чем у красно-черного 
          дерева (за счет уменьшения количества разбираемых случаев). 
          
          Оценка на высоту деревьев остается прежней, 2*log2(n). 
          
          Эффективность по времени у них примерно одинаковая, но так как в реализации вместо цвета
          обычно хранят другую характеристику («уровень» вершины), overhead по памяти достигает байта.

    3) АВЛ-дерево
    
        Названо так по фамилиям придумавших его советских математиков: Г.М. Адельсон-Вельского 
        и Е.М. Ландиса.

        Накладывает на дерево следующее ограничение: у любой вершины высоты левого и 
        правого поддеревьев должны отличаться не более чем на 1. 
        Легко доказать по индукции, что дерево с высотой h должно содержать как минимум F_h вершин, 
        где F_i — i-ое число Фибоначчи. Так как F_i ~ phi^n (phi=(sqrt(5)+1)/2 — золотое сечение), 
        высота дерева с n вершинами не может превысить log2(n)/log2(phi) ~ 1.44*log2(n)

        Реализация, как и у красно-черного дерева, основана на разборе случаев и достаточно 
        сложна для понимания (хотя имхо проще красно-черного).
        
        Сложность O(log(n)) на все основные операции. 
        
        Для работы необходимо хранить в каждой вершине разницу между высотами левого и 
        правого поддеревьев. Так как она не превосходит 1, достаточно использовать 2 бита на вершину.
        
    4) Декартово дерево
    
    Декартово дерево . Другие названия: Cartesian tree, treap (tree+heap), дуча (дерево+куча).

    Если рисовать дерево на плоскости, ключ будет соответствовать x-координате вершины 
    (за счет упорядоченности). Тогда можно ввести и y-координату (назавем ее высотой), 
    которая будет обладать следующим свойством: высота вершины больше высоты детей 
    (такое же свойство имеют значения в другой структуре данных на основе двоичных 
    деревьев — куче (heap). Отсюда второй вариант названия той структуры)

    Оказывается, если высоты выбирать случайным образом, высота дерева, удовлетворяющего 
    свойству кучи наиболее вероятно будет O(log(n)). 
    
    Численные эксперименты показывают, что высота получается примерно 3*log(n).

    Реализация операций проста и логична, за счет этого структура очень любима в спортивном программировании).
    По результатам тестирования, признана наиболее эффективной по времени (среди 
      красно-черных, 
      AA и 
      АВЛ — деревьев, 
      а так же skip-list'ов (структура, не являющаяся двоичным деревом, но с аналогичной областью применения)
        и radix-деревьев). 
        
    К сожалению, обладает достаточно большим overheadом по памяти (2-4 байта на вершину, 
    на хранение высоты) и неприминима там, где требуется гарантированная производительность (например в ядре ОС).
    5) Splay-дерево (скошенное дерево)
    
      Эта структура данных сильно отличается от всех перечисленных до этого. 
      Дело в том, что оно не накладывает никаких ограничений на структуру дерева. 
      Более того, в процессе работы дерево может оказаться полностью разбалансированным!

      Основа splay-дерева — операция splay. 
      Она находит нужную вершину (или ближайшую к ней при отсутствии) и «вытягивает» ее в корень 
      особой последовательностью элементарных вращений (локальная операция над деревом, 
      сохраняющая свойство порядка, но меняющая структуру). 
      Через нее можно легко выразить все основные операции с деревом. 
      Последовательность операций в splay подобрана так, чтобы дерево «магически» работало быстро.

      Зная магию операции splay, эти деревья реализуются не легко, а очень легко, поэтому они 
      тоже очень популярны в ACM ICPC, Topcoder etc. 

      Ясно, что в таком дереве нельзя гарантировать сложность операций O(log(n)) 
        (вдруг нас попросят найти глубоко залегшую вершину в несбалансированном на данный момент дереве?). 
      
      Вместо этого, гарантирается амортизированная сложность операции O(log(n)), то есть любая последовательность 
      из m операций с деревом размера n работает за O((n+m)*log(n)). 
      
      Более того, splay-дерево обладает некоторыми магическими свойствами, за счет которого оно на практике 
      может оказаться намного эффективнее остальных вариантов. 
      
          Например, вершины, к которым обращались недавно, оказываются ближе к корню и доступ к ним ускоряется. 
          Более того, доказано что если вероятности обращения к элементам фиксированы, то splay-дерево будет 
          работать асимптотически не медленней любой другой реализации бинарных деревьев. 
          
          Еще одно преимущество в том, что отсутствует overhead по памяти, так как не нужно хранить никакой 
          дополнительной информации.

      В отличие от других вариантов, операция поиска в дереве модифицирует само дерево, поэтому в случае 
      равномерного обращения к элементам splay-дерево будет работать медленней. 
      Однако на практике оно часто дает ощутимый прирост производительности. 
      
          Тесты это подтверждают — в тестах, полученных на основе Firefox'а, VMWare и Squid'а, 
            splay-дерево показывает прирост производительности в 1.5-2 раза по сравнению с красно-черными и АВЛ- деревьями. 
          
          В тоже время, на синтетических тестах splay-деревья работают в 1.5 раза медленней. 
          К сожалению, из-за отсутствия гарантий на производительность отдельных операций, splay-деревья неприминимы 
          в realtime-системах (например в ядре ОС, garbage-collector'ах), а так же в библиотеках общего назначения.
          
    6) Scapegoat-дерево ('козел отпущения')
    
      Это дерево похоже на предыдущее тем, что у него отсутствует overhead по памяти. 
      Однако это дерево является в полной мере сбалансированным. 
      
      Более того, коэффициент 0 < alpha < 0.5 «жесткости» дерева можно задавать произвольно и 
      высота дерева будет ограничена сверху значением k*log(n)+1, где k=log2(1/alpha). 
      
      К сожалению, операции модификации будут амортизированными как и у прошлого дерева.

      Коэффициент жесткости сильно влияет на баланс производительности: чем «жестче» дерево, 
      тем меньше у него будет высота и тем быстрее будет работать поиск, но тем сложнее будет 
      поддерживать порядок в операциях модификации. 
      
        Например, так как АВЛ-дерево «жестче» красно-черного, 
          поиск в нем работает быстрее, а модификация медленней. 
        
        Если же пользоваться scapegoat-деревом, баланс между этими операциями можно 
        выбирать в зависимости от специфики применения дерева.
    
2. Пространственные индексы

В схеме работы пространственных запросов обычно выделяют две стадии или две ступени фильтрации. 
  СУБД, обладающие слабой пространственной поддержкой, отрабатывают только первую ступень (грубая фильтрация, MySQL). 
  Как правило, на этой стадии используется приближенное, аппроксимированное представление объектов. 
  Самый распространенный тип аппроксимации – минимальный ограничивающий прямоугольник (MBR – Minimum Bounding Rectangle).
  
Для пространственных типов данных существуют особые методы индексирования на основе 
  R-деревьев(R-Tree index) и 
  сеток(Grid-based Spatial index).
  
  Spatial grid

  2.1. Spatial grid(пространственная сетка) index – это древовидная структура, подобная B-дереву, 
     но используется для организации доступа к пространственным(Spatial) данным, то есть для индексации многомерной информации, 
     такой, например, как географические данные с двумерными координатами(широтой и долготой). 
     
     В этой структуре узлами дерева выступают ячейки пространства. 
     Например, для двухмерного пространства: сначала вся родительская площадь будет разбита на сетку строго 
     определенного разрешения, затем каждая ячейка сетки, в которой количество объектов превышает установленный 
     максимум объектов в ячейке, будет разбита на подсетку следующего уровня. 
     Этот процесс будет продолжаться до тех пор, пока не будет достигнут максимум вложенности (если установлен), 
     или пока все не будет разделено до ячеек, не превышающих максимум объектов. 
     
     В случае трехмерного или многомерного пространства это будут прямоугольные параллелепипеды (кубоиды) или параллелотопы.

  2.2. Quadtree (квадрадерево)

     Quadtree – это подвид Grid-based Spatial index, в котором в родительской ячейке всегда 4 потомка и разрешение сетки варьируется
     в зависимости от характера или сложности данных.
     
  2.3. R-Tree (Регионы дерево)

     R-Tree (Regions Tree) – это тоже древовидная структура данных подобная Spatial Grid, предложенная в 1984 году Антонином Гуттманом. 
     Эта структура данных тоже разбивает пространство на множество иерархически вложенных ячеек, но которые, в отличие от Spatial Grid, 
     не обязаны полностью покрывать родительскую ячейку и могут пересекаться.

     Для расщепления переполненных вершин могут применяться различные алгоритмы, что порождает деление R-деревьев на подтипы: 
       с квадратичной и линейной сложностью.
       
     Квадратичный подтип заключается в разбиении на два прямоугольника с минимальной площадью, покрывающие все объекты. 
     Линейный – в разбиении по максимальной удаленности. 
     
3. HASH

  Hash-индексы были предложены Артуром Фуллером, и предполагают хранение не самих значений, а их хэшей, 
    благодаря чему уменьшается размер(а, соответственно, и увеличивается скорость их обработки) 
    индексов из больших полей. 
    
    Таким образом, при запросах с использованием HASH-индексов, сравниваться будут не искомое со значения поля, 
    а хэш от искомого значения с хэшами полей. 
    
    Из-за нелинейнойсти хэш-функций данный индекс нельзя сортировать по значению, что приводит к невозможности 
    использования в сравнениях больше/меньше и «is null». 
    Кроме того, так как хэши не уникальны, то для совпадающих хэшей применяются методы разрешения коллизий.
    
4. Bitmap (Битовая карта)

  Bitmap index – метод битовых индексов заключается в создании отдельных битовых карт (последовательность 0 и 1) 
    для каждого возможного значения столбца, где каждому биту соответствует строка с индексируемым значением, 
    а его значение равное 1 означает, что запись, соответствующая позиции бита содержит индексируемое значение
    для данного столбца или свойства.
    
  Основное преимущество битовых индексов в том, что на больших множествах с низкой мощностью и 
    хорошей кластеризацией по их значениям индекс будет меньше чем B*-tree.

5. Reverse index (Обратный индекс)

   Reverse index – это тоже B-tree индекс но с реверсированным ключом, 
   используемый в основном для монотонно возрастающих значений(например, автоинкрементный идентификатор) 
   в OLTP системах с целью снятия конкуренции за последний листовой блок индекса, 
   т.к. благодаря переворачиванию значения две соседние записи индекса попадают в разные блоки индекса. 
   
   Он не может использоваться для диапазонного поиска.
   
   Как видите, значение в индексе изменяется намного больше, чем само значение в таблице, и поэтому 
   в структуре b-tree, они попадут в разные блоки. 
   
6. Inverted index (Перевернутый индекс)

   Инвертированный индекс – это полнотекстовый индекс, хранящий для каждого лексемы ключей отсортированный 
   список адресов записей таблицы, которые содержат данный ключ.

7. Partial index (Частичный индекс)

   Partial index — это индекс, построенный на части таблицы, удовлетворяющей определенному условию самого индекса. 
     Данный индекс создан для уменьшения размера индекса.
     
     Пример :  partial index из Postgre SQL, пример из доки:

      CREATE INDEX access_log_client_ip_ix 
          ON access_log (client_ip)
       WHERE NOT (client_ip > inet '192.168.100.0' 
              AND client_ip < inet '192.168.100.255');

      A typical query that can use this index would be:

      SELECT * 
        FROM access_log 
       WHERE url = '/index.html' 
         AND client_ip = inet '212.78.10.32';
   
   Как можно сделать частичный индекс с помощью функционального в Oracle ?
   
      Создав функциональный индекс, который при удовлетворяющих условию значениях 
        будет возвращать само значение, в противном случае одинаковое маленькое заранее
        опреденное значение. Таким образом индекс станет меньше чем обычный как 
        по размеру самих данных, так и по количеству в нем ветвей, но, 
        конечно, он будет побольше.
        
        Указатели на неудовлетворящие условию ряды будут, но все они будут в одном листе дерева.
        Например, пусть есть таблица полем id заполненным от 1 до 1000000. Создаем функциональный 
        индекс возвращающий -1 для всех кроме диапазона от 1 до 100. В таком случае у нас дерево для 
        индекса будет высотой всего в 7 вместо 20

8. Function-based index (функциональный индекс)

  Самим же гибким типом индексов являются функциональные индексы, то есть индексы, 
    ключи которых хранят результат пользовательских функций. 
    
  Функциональные индексы часто строятся для полей, значения которых проходят 
    предварительную обработку перед сравнением в команде SQL. 
    
  Например, при сравнении строковых данных без учета регистра символов часто используется функция UPPER. 
  
  Создание функционального индекса с функцией UPPER улучшает эффективность таких сравнений.
  
--------------------------------------------------------------------------------------------------------------------  

Сводная таблица типов индексов
Картинка во вложении
